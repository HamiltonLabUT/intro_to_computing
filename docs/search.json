[
  {
    "objectID": "intro_to_computing.html",
    "href": "intro_to_computing.html",
    "title": "Introduction to Computing, Unix, and the Command Line",
    "section": "",
    "text": "Overview\n\n\n\nThis tutorial includes information about how to think about computers and how to use the command line (on Mac and Unix systems). This is heavily inspired by Chris Paciorek’s course."
  },
  {
    "objectID": "intro_to_computing.html#files-and-directories",
    "href": "intro_to_computing.html#files-and-directories",
    "title": "Introduction to Computing, Unix, and the Command Line",
    "section": "Files and directories",
    "text": "Files and directories\n\nMoving around and listing information\nWe’ll start by thinking about the filesystem, which organizes our information/data into files on the computer’s disk.\nAnytime you are at the UNIX command line, you have a working directory, which is your current location in the file system.\nHere’s how you can see where you are using the pwd (“print working directory”) command:\n% pwd\n/Users/liberty/Documents/Austin/code/intro_to_computing\nand here’s how you use ls to list the files (and subdirectories) in the working directory…\n% ls\nassets    LICENSE    README.md    intro_to_computing.qmd\nNow suppose I want to be in a different directory so I can see what is there or do things to the files in that directory.\nThe command you need is cd (“change directory”) and an important concept you need to become familiar with is the notion of ‘relative’ versus ‘absolute’ path. A path is the set of nested directories that specify a location of interest on the filesystem.\nNow let’s go into a subdirectory. We can use cd with the name of the subdirectory. The subdirectory is found ‘relative’ to our working directory, i.e., found from where we currently are.\n% cd assets\n% pwd\n/Users/liberty/Documents/Austin/code/intro_to_computing/assets\nWe could also navigate through nested subdirectories. For example, after going back to our home directory (using cd alone will do this), let’s go to the units subdirectory of the compute-skills-2024 subdirectory. The / is a separate character that distinguishes the nested subdirectories.\n% cd\n% pwd\n/Users/liberty\n% cd Documents/Austin/code/intro_to_computing/assets\nYou can access the parent directory of any directory using ..:\n% cd ..\n% pwd\n/Users/liberty/Documents/Austin/code/intro_to_computing\nWe can get more complicated in our use of .. with relative paths. Here we’ll go up a directory and then down to a different subdirectory.\n$ cd other\n$ cd ../assets\n$ pwd\n/Users/liberty/Documents/Austin/code/intro_to_computing/assets\nAnd here we’ll go up two directories and then down to another subdirectory.\n$ cd ../../match_filter  # Go up two directories and down.\n$ pwd\n/Users/liberty/Documents/Austin/code/match_filter\n\n\nAbsolute versus relative paths\nAll of the above examples used relative paths to navigate based on your working directory at the moment you ran the command.\nWe can instead use absolute paths so that it doesn’t matter where we are when we run the command. Specifying an absolute path is done by having your path start with /, such as /Users/liberty. If the path doesn’t start with / then it is interpreted as being a relative path, relative to your working directory. Here we’ll go to the units subdirectory again, but this time using an absolute path.\n$ cd /Users/liberty/Documents/Austin/code/intro_to_computing\n$ pwd\n/Users/liberty/Documents/Austin/code/intro_to_computing\n\n\n\n\n\n\nAbsolute paths can be dangerous\n\n\n\nIt’s best to generally use relative paths, relative to the main directory of a project.\nUsing absolute paths is generally a bad idea for reproducibility and automation because the file system will be different on different machines, so your code wouldn’t work correctly anywhere other than your current machine."
  },
  {
    "objectID": "intro_to_computing.html#using-commands",
    "href": "intro_to_computing.html#using-commands",
    "title": "Introduction to Computing, Unix, and the Command Line",
    "section": "Using commands",
    "text": "Using commands\n\nOverview\nLet’s look more at various ways to use commands. We just saw the ls command. Here’s one way we can modify the behavior of the command by passing a command option. Here the -F option (also called a flag) shows directories by appending / to anything that is a directory (rather than a file) and a * to anything that is an executable (i.e., a program).\n$ cd /Users/liberty/Documents/Austin/code/intro_to_computing\n$ ls -F\n$ ls -F /usr/bin\nNext we’ll use multiple options to the ls command. -l shows extended information about files/directories. -t shows files/directories in order of the time at which they were last modified and -r shows in reverse order.\nWhile each command has its own syntax, there are some rules usually followed. Generally, executing a command consists of four things:\n\nthe command\ncommand option(s)\nargument(s)\nline acceptance (i.e., hitting )\n\nHere’s an example:\n$ echo \"hello there\" &gt;&gt; example.txt\n$ echo \"and goodbye\" &gt;&gt; example.txt\n$ echo \"really now\" &gt;&gt; example.txt\n$ wc -l example.txt\n3 example.txt\nIn the above example, wc is the command, -l is a command option specifying to count the number of lines, example.txt is the argument, and the line acceptance is indicated by hitting the &lt;Return&gt; key at the end of the line.\nSo that invocation counts the number of lines in the file named example.txt.\nThe spaces are required and distinguish the different parts of the invocation. For this reason, it’s generally a bad idea to have spaces within file names. But if you do, you can use quotation marks to distinguish the file name, e.g.,\n$ ls -l \"name of my file with spaces.txt\"\nAlso, capitalization matters. For example -l and -L are different options.\nNote that options, arguments, or both might not be included in some cases. Recall that we’ve used ls without either options or arguments.\nArguments are usually one or more files or directories.\n\n\nOptions\nOften we can specify an option either in short form (as with -l here) or long form (--lines here), as seen in the following equivalent invocations:\n$ wc -l example.txt\n3 example.txt\n$ wc --lines example.txt\n3 example.txt\nWe can also ask for the number of characters with the -m option, which can be combined with the -l option equivalently in two ways:\n$ wc -lm example.txt\n  3 35 example.txt\n$ wc -l -m example.txt\n  3 35 example.txt\nOptions will often take values, e.g., if we want to get the first two lines of the file, the following invocations are equivalent:\n$ head -n 2 example.txt\n$ head --lines=2 example.txt\n$ head --lines 2 example.txt\n\n\nComments\nAnything that follows # is a comment and is ignored.\n$ # This is ignored\n$ ls  # Everything after the # is ignored\n compute-skills-2024                          test-jh           Untitled2.ipynb\n data_c80_regsample_3.dta                     test-private      Untitled3.ipynb\n\n\nGetting help with UNIX commands\nEssentially all UNIX commands have help information (called a man page), accessed using man.\n$ man ls\nOnce you are in the man page, you can navigate by hitting &lt;space&gt; (to scroll down) and the &lt;up&gt; and &lt;down&gt; arrows. You can search by typing /, typing the string you want to search for and hitting &lt;Return&gt;. You can use n and p for the next and previous search hits and q to quit out of the search.\nUnfortunately man pages are often quite long, hard to understand, and without examples. But the information you need is usually there if you take the time to look for it.\nAlso, UNIX commands as well as other programs run from the command line often provide help information via the --help option, e.g., for help on ls:\n$ ls --help\n\n\nTab completion\nIf you hit Tab the shell tries to figure out what command or filename you want based on the initial letters you typed.\nTry it with:\ncd com\nech\nThe first should allow you to get compute-skills-2024 and the second echo.\n\n\n\n\n\n\nTab completion everywhere\n\n\n\nLots of interactive programs have adopted the idea of tab completion, including Python/IPython and R.\n\n\n\n\nCommand history\nHit the up key. You should see the previous command you typed. Hit it again. You should see the 2nd most recent command.\nCtrl-a and Ctrl-e navigate to the beginning and end of a line. You can edit your previous command and then hit Enter to run the modified code.\n\n\nSeeing if a command or program is available\nYou can see if a command or program is installed (and where it is installed) using type.\n$ type grep\ngrep is /usr/bin/grep\n$ type R\nR is /usr/bin/R\n$ type python\npython is /srv/conda/bin/python"
  },
  {
    "objectID": "intro_to_computing.html#working-with-files",
    "href": "intro_to_computing.html#working-with-files",
    "title": "Introduction to Computing, Unix, and the Command Line",
    "section": "Working with files",
    "text": "Working with files\n\nCopying and removing files\nYou’ll often want to make a copy (cp) of a file, move it (mv) between directories, or remove it (rm).\n$ cd ~/compute-skills-2024/units\n$ cp calc.py calc-new.py\n$ mv calc-new.py /tmp/.\n$ cd /tmp\n$ ls -lrt\ntotal 8\ndrwx-----T 2 jovyan jovyan 4096 Aug  1 16:15 jupyter-runtime\n-rw-r--r-- 1 jovyan jovyan  413 Aug  1 16:16 calc-new.py\nWhen we moved the file, the use of . in /tmp/. indicates we want to use the same name as the original file.\n$ rm calc-new.py\n$ ls -lrt\ntotal 4\ndrwx-----T 2 jovyan jovyan 4096 Aug  1 16:15 jupyter-runtime\n\n\n\n\n\n\nrm cannot be undone\n\n\n\nI used rm above to remove the file. Be very careful about removing files - there is no Trash folder in UNIX - once a file is removed, it’s gone for good.\n\n\nThe mv command is also used if you want to rename a file.\n$ cd ~/compute-skills-2020/units\n$ mv session3.qmd _sesson3.qmd\n$ ls"
  },
  {
    "objectID": "intro_to_computing.html#exercises-shell-commands",
    "href": "intro_to_computing.html#exercises-shell-commands",
    "title": "Introduction to Computing, Unix, and the Command Line",
    "section": "Exercises: shell commands",
    "text": "Exercises: shell commands\n\n\n\n\n\n\nExercise 1\n\n\n\nWhere is gzip installed on the system? What are some other commands/executables that are installed in the same directory?\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nTry to run the following command mkdir ~/projects/drought. It will fail. Look in the help information on mkdir to figure out how to make it work without first creating the projects directory.\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nFigure out how to list out the files in a directory in order of decreasing file size, as a way to see easily what the big files are that are taking up the most space. Modify this command to get the result in the ascending order.\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nFigure out how to copy an entire directory and have the timestamps of the files retained rather than having the timestamps be the time that you copied the files.\nSee if you can combine the short form of an option with the long form of a different option.\nWhat happens if you use a single dash with the long form of an option. Are you able to interpret the error message? (Note that confusingly there are some situations one can use the long form with a single dash.)"
  },
  {
    "objectID": "intro_to_computing.html#running-processes",
    "href": "intro_to_computing.html#running-processes",
    "title": "Introduction to Computing, Unix, and the Command Line",
    "section": "Running processes",
    "text": "Running processes\nWe’ll run a simple linear algebra operation in Python to illustrate how we can monitor what is happening on a machine.\n\n\n\n\n\n\nDataHub memory limits\n\n\n\nBe careful about increasing n in the example below when on DataHub. Basic DataHub virtual machines by default only have 1 GB memory, so don’t increase n below or you may run out of memory if running on DataHub and this can cause problems in your DataHub session. If you’re doing this as part of the workshop, we’ve increased those limits somewhat, so somewhat larger values of n should be fine.\n\n\n\n\nCode\nimport numpy as np\nimport time\n\ndef run_linalg(n):\n    z = np.random.normal(0, 1, size=(n, n))\n    print(time.time())\n    x = z.T.dot(z)   # x = z'z\n    print(time.time())\n    U = np.linalg.cholesky(x)  # factorize as x = U'U\n    print(time.time())\n\n## This allows us to run the code from the command line\n## without running it when we import the file as a module.\nif __name__ == '__main__':\n    run_linalg(4000)\n\n\npython calc.py\nWe might need to run it in a loop to be able to monitor the running process (since it finishes so quickly):\n\n\nCode\nfor ((i=0;i&lt;10;i++)); do\n  python calc.py\ndone\n\n\n\nMonitoring CPU and memory use\nWe can see CPU and memory usage via top.\nIf we see more than 100% CPU usage, that indicates that the process is running a computation in parallel using multiple threads.\nWhat about if we see less than 100% CPU usage?\n\nOur process might be busy doing I/O (reading/writing to/from disk).\nOur process might be waiting for data from the internet or from another machine on the network.\nThe machine might be running low on physical memory, which in some cases will involve using disk as additional memory (slow!)."
  }
]